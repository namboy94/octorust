/* automatically generated by rust-bindgen */

pub const RETREAT_FUTURE_ALIGNMENT: ::std::os::raw::c_uint = 64;
pub const RETREAT_FUTURE_SIZE: ::std::os::raw::c_uint = 64;
pub const REINVADE_FUTURE_ALIGNMENT: ::std::os::raw::c_uint = 64;
pub const REINVADE_FUTURE_SIZE: ::std::os::raw::c_uint = 64;
pub const INVADE_FUTURE_ALIGNMENT: ::std::os::raw::c_uint = 64;
pub const INVADE_FUTURE_SIZE: ::std::os::raw::c_uint = 64;
pub const PROXY_CLAIM_ALIGNMENT: ::std::os::raw::c_uint = 1;
pub const PROXY_CLAIM_SIZE: ::std::os::raw::c_uint = 2;
pub const _STDINT_H: ::std::os::raw::c_uint = 1;
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201505;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 25;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const __glibc_c99_flexarr_available: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __GLIBC_USE_LIB_EXT2: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: ::std::os::raw::c_uint = 0;
pub const _BITS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPESIZES_H: ::std::os::raw::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::std::os::raw::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::std::os::raw::c_uint = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: ::std::os::raw::c_uint = 1;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _BITS_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_int = -1;
pub const UINT_FAST32_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_uint = 0;
pub const WINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const cf_zlib: ::std::os::raw::c_uint = 1;
pub const cf_hw_dev_iNoCQueSize: ::std::os::raw::c_uint = 1024;
pub const cf_hw_dev_vcpuStacksize: ::std::os::raw::c_uint = 1048576;
pub const cf_hw_hal_vtimer_irq: ::std::os::raw::c_uint = 14;
pub const cf_hw_hal_vga_width: ::std::os::raw::c_uint = 800;
pub const cf_hw_hal_vga_height: ::std::os::raw::c_uint = 600;
pub const cf_hw_hal_memArea_tlm_alignment: ::std::os::raw::c_uint = 8;
pub const cf_hw_dev_cic_emu_buf_size: ::std::os::raw::c_uint = 256;
pub const cf_hw_dev_cic_emu_irq_vec: ::std::os::raw::c_uint = 10;
pub const cf_os_proc_stackAlignmentBits: ::std::os::raw::c_uint = 20;
pub const cf_os_proc_contextQueueSize: ::std::os::raw::c_uint = 16;
pub const cf_os_proc_contextCount: ::std::os::raw::c_uint = 4;
pub const cf_os_proc_fibreLocalDataSlots: ::std::os::raw::c_uint = 4;
pub const cf_os_proc_contextStealRounds: ::std::os::raw::c_uint = 1;
pub const cf_os_proc_contextGuardPageCount: ::std::os::raw::c_uint = 1;
pub const cf_os_proc_ilet_claim_tag_bits: ::std::os::raw::c_uint = 4;
pub const cf_os_proc_ilet_concurrent_claim_tags: ::std::os::raw::c_uint = 4;
pub const cf_os_proc_ilet_appl_class_bits: ::std::os::raw::c_uint = 4;
pub const cf_os_proc_ilet_appl_class_count: ::std::os::raw::c_uint = 8;
pub const cf_os_proc_app_prot_none: ::std::os::raw::c_uint = 1;
pub const cf_security_demo: ::std::os::raw::c_uint = 0;
pub const cf_mpi_maxproc_per_tile: ::std::os::raw::c_uint = 4;
pub const cf_mpi_aligned_dma: ::std::os::raw::c_uint = 1;
pub const cf_mpi_async: ::std::os::raw::c_uint = 1;
pub const cf_hw_sys_arch_name: &'static [u8; 9usize] = b"x86guest\x00";
pub const cf_hw_sys_icore_support: ::std::os::raw::c_uint = 1;
pub const cf_hw_hal_tlm_start: ::std::os::raw::c_uint = 0;
pub const cf_hw_sys_max_cores_per_tile: ::std::os::raw::c_uint = 16;
pub const cf_hw_tile_iotile_support: ::std::os::raw::c_uint = 1;
pub const cf_hw_dev_inoc_ts_count: ::std::os::raw::c_uint = 8;
pub const cf_hw_sys_max_io_tiles: ::std::os::raw::c_uint = 1;
pub const cf_hw_hal_shm_start: ::std::os::raw::c_uint = 0;
pub const cf_hw_dev_inoc_vc_count: ::std::os::raw::c_uint = 4;
pub const cf_hw_sys_tcpa_support: ::std::os::raw::c_uint = 1;
pub const cf_hw_dev_inoc_sl_count: ::std::os::raw::c_uint = 4;
pub const cf_hw_tile_icore_support: ::std::os::raw::c_uint = 1;
pub const cf_hw_sys_iotile_support: ::std::os::raw::c_uint = 1;
pub const cf_hw_tile_tcpa_support: ::std::os::raw::c_uint = 1;
pub const cf_hw_sys_exclusive_irq_core: ::std::os::raw::c_uint = 0;
pub const cf_hw_sys_max_tiles: ::std::os::raw::c_uint = 4;
pub const cf_hw_sys_max_icores: ::std::os::raw::c_uint = 1;
pub const cf_hw_hal_shm_size: ::std::os::raw::c_uint = 268435456;
pub const cf_hw_sys_max_tcpa_tiles: ::std::os::raw::c_uint = 1;
pub const cf_hw_tile_max_cores_per_tile: ::std::os::raw::c_uint = 16;
pub const cf_hw_hal_tlm_size: ::std::os::raw::c_uint = 134217728;
pub const cf_hw_sys_max_compute_tiles: ::std::os::raw::c_uint = 4;
pub const SIMPLE_ILET_ALIGNMENT: ::std::os::raw::c_uint = 8;
pub const SIMPLE_ILET_SIZE: ::std::os::raw::c_uint = 16;
pub const DISPATCH_CLAIM_ALIGNMENT: ::std::os::raw::c_uint = 1;
pub const DISPATCH_CLAIM_SIZE: ::std::os::raw::c_uint = 2;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__fsid_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fsid_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(::std::mem::size_of::<max_align_t>() , 32usize , concat ! (
               "Size of: " , stringify ! ( max_align_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const max_align_t ) ) .
                __clang_max_align_nonce1 as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __clang_max_align_nonce1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const max_align_t ) ) .
                __clang_max_align_nonce2 as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __clang_max_align_nonce2 ) ));
}
impl Clone for max_align_t {
    fn clone(&self) -> Self { *self }
}
pub type claim_t = u8;
pub type tile_id_t = u8;
pub type tile_quantity_t = u8;
pub type pe_quantity_t = u32;
pub type pe_quantity_delta_t = i32;
pub type team_size_t = u32;
#[repr(u32)]
/** Agent Types */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ResType { RISC = 0, iCore = 1, TCPA = 2, none = 3, TYPE_ALL = 4, }
pub type res_type_t = u8;
/**
 * \brief Represents a os::agent::AbstractAgentOctoClaim* in the C interface.
 *
 * Represents a os::agent::AbstractAgentOctoClaim* in the C interface. So an agentclaim_t must be castable to a os::agent::AbstractAgentOctoClaim* via static cast.
 * The os::agent::AbstractAgentOctoClaim* can usually be used directly, but sometimes needs to be downcasted to one of its two subclasses. To enable downcasting, the AbstractAgentOctoClaim* must be castable to a os::agent::AgentOctoClaim* XOR a os::agent::ProxyAgentOctoClaim* via methods os::agent::AbstractAgentOctoClaim::asPAOC() respectively os::agent::AbstractAgentOctoClaim::asAOC() depending on what it represents.
 * As a rule of thumb, as a function parameter, the agentclaim_t can be casted to either the one or the other class; as a function return value, the agentclaim_t is mostly only castable to a os::agent::AgentOctoClaim*, except for method agent_proxy_get_proxyagentoctoclaim (only castable to a os::agent::ProxyAgentOctoClaim*).
 * Whether an agentclaim_t is castable to the one or the other subclass of os::agent::AbstractAgentOctoClaim is noted in all methods of the C interface, so don't worry.
 * os::agent::ProxyAgentOctoClaims can be used in an iLet to access an iLet's os::agent:AgentOctoClaim, even if the iLet does not run on the tile where the os::agent:AgentOctoClaim object is located.
 */
pub type agentclaim_t = *mut ::std::os::raw::c_void;
/**
 * \brief Represents a os::agent::Constraints* in the C interface.
 *
 * Represents a os::agent::Constraints* in the C interface. So a constraints_t must be castable to a os::agent::Constraints* via static cast.
 */
pub type constraints_t = *mut ::std::os::raw::c_void;
/**
 * \brief Represents a os::agent::AgentInstance* in the C interface.
 *
 * Represents aos::agent::AgentInstance* in the C interface. So a agent_t must be castable to a os::agent::AgentInstance* via static cast.
 */
pub type agent_t = *mut ::std::os::raw::c_void;
pub type gain_t = *mut ::std::os::raw::c_void;
pub type loss_t = *mut ::std::os::raw::c_void;
pub type resize_env_t = *mut ::std::os::raw::c_void;
pub type resize_handler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: agentclaim_t,
                                               arg2: usize, arg3: usize,
                                               arg4: gain_t, arg5: loss_t,
                                               arg6: resize_env_t)>;
pub type reinvade_handler_t = ::std::option::Option<unsafe extern "C" fn()>;
/** Size type for DMA buffers. */
pub type buf_size_t = u32;
/** \file octo_ilet.h
 *
 * \brief Functions regarding iLets
 *
 * An iLet is the basic abstraction of an user control flow in OctoPOS.
 *
 * Reviewed by Jens @ 11.02.2013
 */
pub type ilet_func =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void)>;
pub type dual_ilet_func =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2:
                                                   *mut ::std::os::raw::c_void)>;
/**
 * @struct simple_ilet
 * Opaque type for simple_ilet
 *
 * This type is used to allocate simple_ilet "objects" with the right size.
 * To initialise a variable of this type see function simple_ilet_init().
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct simple_ilet {
    pub padding: [::std::os::raw::c_char; 16usize],
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_simple_ilet() {
    assert_eq!(::std::mem::size_of::<simple_ilet>() , 16usize , concat ! (
               "Size of: " , stringify ! ( simple_ilet ) ));
    assert_eq! (::std::mem::align_of::<simple_ilet>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( simple_ilet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const simple_ilet ) ) . padding as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( simple_ilet ) , "::" ,
                stringify ! ( padding ) ));
}
impl Clone for simple_ilet {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * \brief Initialises a given iLet data structure.
 *
 * @param ilet Pointer to simple_ilet instance
 * @param code Pointer to a function to be executed by the iLet
 * @param param Parameter passed to the function.
 */
    pub fn simple_ilet_init(ilet: *mut simple_ilet, code: ilet_func,
                            param: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn dual_ilet_init(ilet: *mut simple_ilet, code: dual_ilet_func,
                          param1: *mut ::std::os::raw::c_void,
                          param2: *mut ::std::os::raw::c_void);
}
extern "C" {
    /**
 * \brief Returns a pointer to the beginning of the i-let-local data area.
 *
 * Data stored in this area is guaranteed to be valid throughout an i-let's
 * lifetime.
 * OctoPOS guarantees that the area is at least 256 bytes large. The concrete
 * size can be dermined by calling get_ilocal_data_size(). Accesses beyond the
 * end of the area cause undefined behaviour.
 *
 * \return Pointer to i-let-local data. It is the caller's responsibility to
 *         cast this pointer to the desired type.
 */
    pub fn get_ilocal_data() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /**
 * \brief Returns the size of the current i-let's local data area.
 */
    pub fn get_ilocal_data_size() -> usize;
}
/**
 * @struct dispatch_claim
 * Opaque type for dispatch_claim
 *
 * This type is used to allocate dispatch_claim "objects" with the right size.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct dispatch_claim {
    pub padding: [::std::os::raw::c_char; 2usize],
}
#[test]
fn bindgen_test_layout_dispatch_claim() {
    assert_eq!(::std::mem::size_of::<dispatch_claim>() , 2usize , concat ! (
               "Size of: " , stringify ! ( dispatch_claim ) ));
    assert_eq! (::std::mem::align_of::<dispatch_claim>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( dispatch_claim ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dispatch_claim ) ) . padding as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dispatch_claim ) , "::"
                , stringify ! ( padding ) ));
}
impl Clone for dispatch_claim {
    fn clone(&self) -> Self { *self }
}
pub type dispatch_claim_t = dispatch_claim;
extern "C" {
    /**
 * \brief Get a dispatch claim that describes the parent claim
 *
 * Get a dispatch claim that describes the parent claim of the currently
 * running ilet. The parent claim is the claim of the ilet executing the infect
 * call that created the calling ilet.
 * \return dispatch claim describing the parent ilet
 */
    pub fn get_parent_dispatch_claim() -> dispatch_claim_t;
}
extern "C" {
    /**
 * \brief Get a dispatch claim that describes the currently active claim
 *
 * \return dispatch claim describing the claim of the currently running ilet
 */
    pub fn get_own_dispatch_claim() -> dispatch_claim_t;
}
extern "C" {
    pub fn dispatch_claim_infect(claim: dispatch_claim_t,
                                 team: *mut simple_ilet, count: team_size_t);
}
extern "C" {
    pub fn dispatch_claim_infect_single(claim: dispatch_claim_t,
                                        iLet: *mut simple_ilet);
}
extern "C" {
    /** \brief Infects the caller's own claim with a team of i-lets. */
    pub fn infect_self(team: *mut simple_ilet, count: team_size_t);
}
extern "C" {
    /** \brief Infects the caller's own claim with a single i-let. */
    pub fn infect_self_single(iLet: *mut simple_ilet);
}
extern "C" {
    /**
 * \brief Setup a push DMA using a dispatch_claim_t instead of a proxy_claim_t
 *
 * If you don't have a proxy_claim_t of the destination, then a
 * dispatch_claim_t also suffices to setup a push DMA transfer. E.g. this makes
 * it possible to easily DMA back to your parent claim.
 *
 * Address format: On LEON, source and destination pointer have to be in the
 * correct format:
 * - \b local_src is a pointer to the local tlm:
 * Address range according to memory map: 0x80000000-0x80800000 (local address
 * format)
 * - \b remote_dst is a pointer to the remote tlm:
 * Address range according to memory map: Starting from 0x40000000 depending on
 * TID (global address format)
 *
 * On LEON, accesses in program code to the local tlm ALWAYS have to be done via
 * the local 0x80000000 addresses!
 *
 * \param claim Destination claim on which dst_iLet will be submitted to
 * \param local_src Source address in the local TLM (local address format)
 * \param remote_dst Destination address in remote TLM (global address format)
 * \param buf_size Size of the message
 * \param src_iLet i-let that gets submitted at the source side of the transfer,
 * once the DMA operation is finished (or NULL if no i-let is to be executed)
 * \param dst_iLet i-let that gets submitted at the destination side of the
 * transfer once the DMA operation is finished (or NULL if no i-let is to be
 * executed)
 * \return Returns 0 on success; On error -1 is returned: Checks consistency
 * between \b remote_dst and TID in claim
 */
    pub fn dispatch_claim_push_dma(claim: dispatch_claim_t,
                                   local_src: *const ::std::os::raw::c_void,
                                   remote_dst: *mut ::std::os::raw::c_void,
                                   buf_size: buf_size_t,
                                   src_iLet: *mut simple_ilet,
                                   dst_iLet: *mut simple_ilet)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Send an answer iLet to your direct parent claim.
 *
 * This is a shortcut for get_parent_dispatch_claim() followed by a
 * dispatch_claim_infect with one iLet.
 *
 * \param iLet gets sent to your parent claim
 */
    pub fn dispatch_claim_send_reply(iLet: *mut simple_ilet);
}
extern "C" {
    pub fn dispatch_claim_get_tid(dc: dispatch_claim_t) -> tile_id_t;
}
/**
 * @struct proxy_claim
 * ProxyClaims are system data structures: Hence, only a Pointer is needed.
 */
pub type proxy_claim_t = *mut ::std::os::raw::c_void;
/**
 * @struct invade_future
 * Opaque type for invade_future
 *
 * This type is used to allocate invade_future "objects" with the right size.
 */
#[repr(C)]
pub struct invade_future {
    pub padding: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_invade_future() {
    assert_eq!(::std::mem::size_of::<invade_future>() , 64usize , concat ! (
               "Size of: " , stringify ! ( invade_future ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const invade_future ) ) . padding as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( invade_future ) , "::"
                , stringify ! ( padding ) ));
}
pub type invade_future_t = invade_future;
/**
 * @struct reinvade_future
 * Opaque type for reinvade_future
 *
 * This type is used to allocate reinvade_future "objects" with the right size.
 */
#[repr(C)]
pub struct reinvade_future {
    pub padding: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_reinvade_future() {
    assert_eq!(::std::mem::size_of::<reinvade_future>() , 64usize , concat ! (
               "Size of: " , stringify ! ( reinvade_future ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const reinvade_future ) ) . padding as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( reinvade_future ) ,
                "::" , stringify ! ( padding ) ));
}
pub type reinvade_future_t = reinvade_future;
#[repr(C)]
pub struct retreat_future {
    pub padding: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_retreat_future() {
    assert_eq!(::std::mem::size_of::<retreat_future>() , 64usize , concat ! (
               "Size of: " , stringify ! ( retreat_future ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const retreat_future ) ) . padding as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( retreat_future ) , "::"
                , stringify ! ( padding ) ));
}
pub type retreat_future_t = retreat_future;
extern "C" {
    /**
 * \brief Get the proxy claim returned from a previous proxy_invade
 *
 * Use this to get the return value from a previous proxy_invade call. On
 * success this is a pointer to a proxy claim object or 0 on failure. If the
 * remote_invade hasn't finished, this call will block until it has.
 *
 * \param fut pointer to the future provided to proxy_invade
 * \return if successful, returns a reference to a proxy claim object. Returns
 * 0 if the invade request could not be satisfied
 */
    pub fn invade_future_force(fut: *mut invade_future_t) -> proxy_claim_t;
}
extern "C" {
    /**
 * \brief Get return value for reinvade
 *
 * Use this to get return value from previously triggered reinvade. Blocks
 * until reinvade has finished.
 *
 * \param fut Pointer to future that was provided to proxy_reinvade
 * \return Returns 0 on success, -1 on error
 */
    pub fn reinvade_future_force(fut: *mut reinvade_future_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Get return value for retreat
 *
 * Use this to get return value from previously triggered retreat. Blocks
 * until retreat has finished.
 *
 * \param fut Pointer to future that was provided to proxy_retreat
 * \return Returns 0 on success, -1 on error
 */
    pub fn retreat_future_force(fut: *mut retreat_future_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Invade creating a new claim; claim can potentially be located on
 * another tile
 *
 * This call primarily serves to invade other tiles in the system. This call is
 * serviced asynchronously: Instead of blocking until the potentially remote
 * resource allocaton has finished, it uses a future object that can be used to
 * access the return value of the call
 *
 * \param fut future object passed by the application. Can be used to get the
 * return value of proxy_invade
 * \param tile_id tile id of the tile you want to invade
 * \param quantity number of PEs to acquire
 * \return 0 on success, -1 on error.
 */
    pub fn proxy_invade(tile_id: tile_id_t, fut: *mut invade_future_t,
                        quantity: pe_quantity_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Change resource allocation on an already existing claim
 *
 * This call changes the resource allocation of a potentially distant claim.
 * This call is, like proxy_invade, also asynchronous, exposing its return
 * value as a future.
 *
 * \param claim Existing proxy claim that shall be modified
 * \param fut Future to query success and completion of operation
 * \param deltaPE change claim size by deltaPE
 */
    pub fn proxy_reinvade(claim: proxy_claim_t, fut: *mut reinvade_future_t,
                          deltaPE: pe_quantity_delta_t);
}
extern "C" {
    /**
 * \brief Change resource allocation on an already existing claim
 *
 * This basically is the same operation as proxy_reinvade, but it is executed
 * synchronously and its result is returned directly.
 *
 * \param claim Existing proxy claim that shall be modified
 * \param deltaPE change claim size by deltaPE
 * \return 0 on success, -1 on error
 */
    pub fn proxy_reinvade_sync(claim: proxy_claim_t,
                               deltaPE: pe_quantity_delta_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief This completely dissolves the claim and frees its resources
 *
 * proxy_retreat completely destroys the claim that is associated with this
 * proxy_claim_t object. This means all cores are freed and afterwards can be
 * invaded by other claims. This call also deletes the proxy_claim_t object
 * itself. Using this reference after the retreat call leads to undefined
 * behaviour.
 *
 * \param claim Existing proxy_claim that shall be retreated from
 * \param fut Future object to query return value and synchronise on completion
 * of the operation
 */
    pub fn proxy_retreat(claim: proxy_claim_t, fut: *mut retreat_future_t);
}
extern "C" {
    /**
 * \brief This completely dissolves the claim and frees its resources
 *
 * This basically is the same operation as proxy_retreat. It completely
 * destroys the claim and the proxy_claim_t, but is executed synchronously and
 * its result is returned directly.
 *
 * \param claim Existing proxy_claim that shall be retreated from
 * \return 0 on success, -1 on error
 */
    pub fn proxy_retreat_sync(claim: proxy_claim_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Executing a team of iLets on a previously created proxy claim
 *
 * \param claim claim of the application the iLet belongs to. The claim defines
 * to which tile and set of cores the ilet is forwarded.
 * \param team Array of iLets forming the team
 * \param count number of iLets forming the team
 */
    pub fn proxy_infect(claim: proxy_claim_t, team: *mut simple_ilet,
                        count: team_size_t);
}
extern "C" {
    /**
 * \brief Setup a push DMA operation
 *
 * iNoC DMAs are push DMAs, so you should submit DMA transfers on the tile that
 * holds the local_src buffer. The claim parameter has to match remote_dst,
 * meaning that the claim wrapped by the proxy_claim_t claim has to reside on
 * the same tile that remote_dst does.
 *
 * Address format: On LEON, source and destination pointer have to be in the
 * correct format:
 * - \b local_src is a pointer to the local tlm:
 * Address range according to memory map: 0x80000000-0x80800000 (local address
 * format)
 * - \b remote_dst is a pointer to the remote tlm:
 * Address range according to memory map: Starting from 0x40000000 depending on
 * TID (global address format)
 *
 * On LEON, accesses in program code to the local tlm ALWAYS have to be done via
 * the local 0x80000000 addresses!
 *
 * \param claim Destination claim on which dst_iLet will be submitted to
 * \param local_src Source address in the local TLM (local address format)
 * \param remote_dst Destination address in remote TLM (global address format)
 * \param buf_size Size of the message
 * \param src_iLet i-let that gets submitted at the source side of the transfer,
 * once the DMA operation is finished (or NULL if no i-let is to be executed)
 * \param dst_iLet i-let that gets submitted at the destination side of the
 * transfer once the DMA operation is finished (or NULL if no i-let is to be
 * executed)
 * \return Returns 0 on success; On error -1 is returned: Checks consistency
 * between \b remote_dst and TID in claim
 */
    pub fn proxy_push_dma(claim: proxy_claim_t,
                          local_src: *const ::std::os::raw::c_void,
                          remote_dst: *mut ::std::os::raw::c_void,
                          buf_size: buf_size_t, src_iLet: *mut simple_ilet,
                          dst_iLet: *mut simple_ilet)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Get TileID of proxy claim
 *
 */
    pub fn proxy_get_tid(claim: proxy_claim_t) -> tile_id_t;
}
extern "C" {
    /**
 * \brief Extract dispatch information from a proxy claim
 *
 * \param claim Proxy claim to extract dispatch information from
 * \return dispatch claim representing dispatch inforamtion of proxy claim
 */
    pub fn proxy_get_dispatch_info(claim: proxy_claim_t) -> dispatch_claim_t;
}
extern "C" {
    /**
 * \brief This API function is unstable, do not use it
 *
 */
    pub fn proxy_get_available_mask() -> usize;
}
extern "C" {
    /**
 * \brief This API function is unstable, do not use it
 *
 */
    pub fn proxy_reinvade_mask(mask: usize) -> ::std::os::raw::c_int;
}
